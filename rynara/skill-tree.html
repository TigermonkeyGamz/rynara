<!-- =========================================
   RYNARA SKILL TREE DEV TOOL
   Viewer Mode + Dev Mode
   Cartesian Grid (0,0 centered)
   Skills lock until requirements met
========================================= -->

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Rynara Skill Tree Dev Tool</title>

<style>
body{
  margin:0;
  overflow:hidden;
  background:#111;
  font-family:sans-serif;
}

#viewport{
  position:absolute;
  width:100%;
  height:100%;
  overflow:hidden;
  cursor:grab;
}

#world{
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
}

.skill{
  position:absolute;
  border-radius:50%;
  display:flex;
  justify-content:center;
  align-items:center;
  font-size:12px;
  text-align:center;
  background:#222;
  color:white;
  user-select:none;
}

.skill.locked{
  filter:grayscale(100%);
  opacity:.4;
}

canvas{
  position:absolute;
  left:0;
  top:0;
  pointer-events:none;
}
</style>
</head>

<body>

<div id="viewport">
  <div id="world">
    <canvas id="grid"></canvas>
    <canvas id="lines"></canvas>
  </div>
</div>

<script>

/* ================
  DEV MODE CONFIG
================ */
const DEV_PASSWORD="rynara-dev";
let DEV_MODE=false;

if(prompt("Enter dev password (Cancel for viewer mode)")===DEV_PASSWORD){
  DEV_MODE=true;
}

/* ================
  GRID SETUP
================ */
const gridSize=4000;
const gridCenter=gridSize/2;
const step=100;

const gridCanvas=document.getElementById("grid");
const gridCtx=gridCanvas.getContext("2d");

const lineCanvas=document.getElementById("lines");
const lineCtx=lineCanvas.getContext("2d");

gridCanvas.width=lineCanvas.width=gridSize;
gridCanvas.height=lineCanvas.height=gridSize;

/* ================
  WORLD CONVERSION
================ */
function worldX(x){return gridCenter+x;}
function worldY(y){return gridCenter-y;}

/* ================
  SKILLS
================ */
const skillData=[
  {id:'warrior',name:'Way of the Warrior',desc:'Increased Melee Damage<br>Skill: Spin',cost:2,parent:null,x:-200,y:0,size:45,borderColor:'#FF0000'},
  {id:'flurry',name:'Flurry',desc:'Attack multiple times in an instant',cost:3,parent:'warrior',x:-350,y:0,size:60,borderColor:'#FF0000'},
  {id:'jump',name:'Jump',desc:'Jump in the air and strike enemies',cost:2,parent:'flurry',x:-550,y:-70,size:60,borderColor:'#FF0000'},
  {id:'p-parry',name:'Power Parry',desc:'Parry as you put up your shield',cost:1,parent:'flurry',x:-550,y:70,size:60,borderColor:'#FF0000'},
  {id:'+block',name:'Increased Shield',desc:'Shields are 5% more effective',cost:1,parent:'p-parry',x:-700,y:100,size:45,borderColor:'#FF0000'}
];

/* ================
  PLAYER STATE
================ */
let unlocked=new Set();

/* ================
  DRAW GRID
================ */
function drawGrid(){
  gridCtx.clearRect(0,0,gridSize,gridSize);
  gridCtx.strokeStyle="#333";

  for(let x=0;x<=gridSize;x+=step){
    gridCtx.beginPath();
    gridCtx.moveTo(x,0);
    gridCtx.lineTo(x,gridSize);
    gridCtx.stroke();
  }

  for(let y=0;y<=gridSize;y+=step){
    gridCtx.beginPath();
    gridCtx.moveTo(0,y);
    gridCtx.lineTo(gridSize,y);
    gridCtx.stroke();
  }
}

/* ================
  AVAILABILITY
================ */
function available(skill){
  if(!skill.parent)return true;
  return unlocked.has(skill.parent);
}

/* ================
  BUILD SKILLS
================ */
const world=document.getElementById("world");
const skillMap={};

function buildSkills(){

  skillData.forEach(skill=>{

    const div=document.createElement("div");
    div.className="skill";
    div.innerHTML=skill.name;
    div.style.width=skill.size+"px";
    div.style.height=skill.size+"px";
    div.style.border="3px solid "+skill.borderColor;

    positionSkill(div,skill);

    if(!available(skill)){
      div.classList.add("locked");
    }

    div.onclick=()=>{
      if(!available(skill))return;

      unlocked.add(skill.id);
      refreshSkills();
    };

    if(DEV_MODE){
      enableDrag(div,skill);
    }

    world.appendChild(div);
    skillMap[skill.id]=div;
  });

}

function refreshSkills(){
  skillData.forEach(skill=>{
    const div=skillMap[skill.id];
    if(available(skill)) div.classList.remove("locked");
    else div.classList.add("locked");
  });

  drawLines();
}

function positionSkill(div,skill){
  div.style.left=(worldX(skill.x)-skill.size/2)+"px";
  div.style.top=(worldY(skill.y)-skill.size/2)+"px";
}

/* ================
  LINES
================ */
function drawLines(){
  lineCtx.clearRect(0,0,gridSize,gridSize);
  lineCtx.strokeStyle="#888";
  lineCtx.lineWidth=2;

  skillData.forEach(skill=>{
    if(!skill.parent)return;

    const parent=skillData.find(s=>s.id===skill.parent);

    lineCtx.beginPath();
    lineCtx.moveTo(worldX(skill.x),worldY(skill.y));
    lineCtx.lineTo(worldX(parent.x),worldY(parent.y));
    lineCtx.stroke();
  });
}

/* ================
  DEV DRAGGING
================ */
function enableDrag(div,skill){

  let dragging=false;

  div.onmousedown=e=>{
    dragging=true;
    e.stopPropagation();
  };

  window.onmouseup=()=>dragging=false;

  window.onmousemove=e=>{
    if(!dragging)return;

    skill.x+=e.movementX;
    skill.y-=e.movementY;

    positionSkill(div,skill);
    drawLines();
  };
}

/* ================
  CAMERA
================ */
const viewport=document.getElementById("viewport");
let camX=0,camY=0;
let dragging=false;

viewport.onmousedown=()=>dragging=true;
window.onmouseup=()=>dragging=false;

window.onmousemove=e=>{
  if(!dragging)return;
  camX+=e.movementX;
  camY+=e.movementY;
  world.style.transform=`translate(calc(-50% + ${camX}px),calc(-50% + ${camY}px))`;
};

/* ================
  INIT
================ */
drawGrid();
buildSkills();
drawLines();

</script>
</body>
</html>
